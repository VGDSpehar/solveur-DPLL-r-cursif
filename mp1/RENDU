                      Mini-projet 1 : solveur DPLL récursif
                             fichier RENDU
                       (à remplir obligatoirement)

**Un mini-projet sans fichier RENDU rempli ne recevra pas de note.**

Date limite: 28 octobre 2022, 23h59

Identité
--------
Nombre de binôme: 4
Nom, prénom 1: Dedeoglu, Dilara  
Nom, prénom 2: Spehar, Victor


Questions sur votre code
------------------------
0. Avez-vous testé que `make dpll` s'exécute sans erreurs ou warnings,
   et que ensuite `./dpll sudoku-4x4.cnf` donne la réponse attendue (voir
   fichier README) ?
   
   -> Oui, Make s'éxécute sans erreurs ni warning.
      ./dpll chemin/vers/sudoku-4x4.cnf affiche :
      SAT
      -111 -112 113 -114 -121 -122 -123 124 -131 132 -133 -134 141 -142 -143 -144 -211 212 -213 -214 221 -222 -223 -224 -231 -232 -233 234 -241 -242 243 -244 311 -312 -313 -314 -321 322 -323 -324 -331 -332 333 -334 -341 -342 -343 344 -411 -412 -413 414 -421 -422 423 -424 431 -432 -433 -434 -441 442 -443 -444 0

      Ce qui est la réponse attendue.

---

1. Avez-vous utilisé la fonction `filter_map` (donné dans dpll.ml)
   dans votre implémentation de `simplifie` ? 
   - Si oui, expliquez en quelques phrases en français comment vous
     l'avez utilisée.
   - Si non, expliquez en quelques phrases en français comment
     fonctionne votre implémentation de `simplifie`.
   
   -> Oui, nous avons utilisé `filter_map` dans  `simplifie`.
      `filter_map` nous permet d'appliquer à chaque clause des clauses la
      fontion auxiliaire `filtrer_l` qui supprime la clause si celle-ci contient l,
      ou bien qui enlève de la clause -l avec un nouvel appel à `filter_map` avec la fonction `enlever_l` sur la clause qui associe Some(x) si x != -l, None sinon.

---

2. Pour l'implémentation de `unitaire`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ? (Par une
   fonction auxiliaire, on entend ici soit une fonction d'une
   bibliothèque, par exemple des fonctions comme `List.length`,
   `List.rev_append`, ou une fonction `aux_unitaire` que vous avez
   écrite vous-mêmes.) Expliquez en quelques phrases en français
   comment ces fonctions auxiliaires sont utilisées dans votre
   implémentation de la fonction `unitaire`.

   -> Pour implémenter `unitaire`, on appelle récursivement la fonction `unitaire`
      sur une liste de liste jusqu'à trouver une clause `unitaire`, c'est à dire
      une liste qui ne comprend qu'un seul élément, le pattern matching nous permet 
      de faire cela sans utiliser de fonction auxiliaire.


---

3. Pour l'implémentation de `pur`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ?  Expliquez en
   quelques phrases en français comment ces fonctions auxiliaires sont
   utilisées dans votre implémentation de la fonction `pur`.

-> 

---

4. Donnez un exemple d'une formule pour laquelle les deux fonctions
   `solveur_split` et `solveur_dpll_rec` ont un comportement
   différent, et expliquez les différences entre ces deux fonctions.

->

---

5. Avez-vous d'autres remarques sur votre rendu ? (question optionnelle)

**à remplir**

---

--fin du fichier RENDU--