                      Mini-projet 1 : solveur DPLL récursif
                             fichier RENDU
                       (à remplir obligatoirement)

**Un mini-projet sans fichier RENDU rempli ne recevra pas de note.**

Date limite: 28 octobre 2022, 23h59

Identité
--------
Nombre de binôme: 4
Nom, prénom 1: Dedeoglu, Dilara  
Nom, prénom 2: Spehar, Victor


Questions sur votre code
------------------------
0. Avez-vous testé que `make dpll` s'exécute sans erreurs ou warnings,
   et que ensuite `./dpll sudoku-4x4.cnf` donne la réponse attendue (voir
   fichier README) ?
   
   -> Oui, Make s'éxécute sans erreurs ni warning.
      ./dpll chemin/vers/sudoku-4x4.cnf affiche :
      SAT
      -111 -112 113 -114 -121 -122 -123 124 -131 132 -133 -134 141 -142 -143 -144 -211 212 -213 -214 221 -222 -223 -224 -231 -232 -233 234 -241 -242 243 -244 311 -312 -313 -314 -321 322 -323 -324 -331 -332 333 -334 -341 -342 -343 344 -411 -412 -413 414 -421 -422 423 -424 431 -432 -433 -434 -441 442 -443 -444 0

      Ce qui est la réponse attendue.

---

1. Avez-vous utilisé la fonction `filter_map` (donné dans dpll.ml)
   dans votre implémentation de `simplifie` ? 
   - Si oui, expliquez en quelques phrases en français comment vous
     l'avez utilisée.
   - Si non, expliquez en quelques phrases en français comment
     fonctionne votre implémentation de `simplifie`.
   
   -> Oui, nous avons utilisé `filter_map` dans  `simplifie`.
      `filter_map` nous permet d'appliquer à chaque clause des clauses la
      fontion auxiliaire `filtrer_l` qui supprime la clause si celle-ci contient l,
      ou bien qui enlève de la clause -l avec un nouvel appel à `filter_map` avec la fonction `enlever_l` sur la clause qui associe Some(x) si x != -l, None sinon.

---

2. Pour l'implémentation de `unitaire`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ? (Par une
   fonction auxiliaire, on entend ici soit une fonction d'une
   bibliothèque, par exemple des fonctions comme `List.length`,
   `List.rev_append`, ou une fonction `aux_unitaire` que vous avez
   écrite vous-mêmes.) Expliquez en quelques phrases en français
   comment ces fonctions auxiliaires sont utilisées dans votre
   implémentation de la fonction `unitaire`.

   -> Pour implémenter `unitaire`, on appelle récursivement la fonction `unitaire`
      sur une liste de liste jusqu'à trouver une clause `unitaire`, c'est à dire
      une liste qui ne comprend qu'un seul élément, le pattern matching nous permet 
      de faire cela sans utiliser de fonction auxiliaire.


---

3. Pour l'implémentation de `pur`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ?  Expliquez en
   quelques phrases en français comment ces fonctions auxiliaires sont
   utilisées dans votre implémentation de la fonction `pur`.

->  On utilise d'abord Liste.flatten sur clauses pour créer une liste d'entier depuis
   la liste de liste d'entier. On applique ensuite une fonction auxiliaire appelée `crible` qui va 
   parcourir la liste d'entier, prendre le premier élément, regarder si son opposé existe 
   dans cette liste avec `List.mem`, si non on a trouvé pur, si oui on va appeller `remove_e_from_l` 
   sur le reste de la liste pour enlever les occurrences de l'élèment qu'on vient de regarder ainsi que les opposés 
   se trouvant dans la liste (afin d'éviter de revérifier dans le futur les mêmes éléments, utiles si la liste est très longue 
   et qu'on ne trouve pas de littéral pur), puis on va repasser la nouvelle liste ainsi créée au `crible` (récursivement). 

---

4. Donnez un exemple d'une formule pour laquelle les deux fonctions
   `solveur_split` et `solveur_dpll_rec` ont un comportement
   différent, et expliquez les différences entre ces deux fonctions.

-> solveur_split simplifie la liste exemple_7_2 en commençant par le littéral 1, 
   tandis que solveur_dpll_rec commence par le littéral -2 car celui-ci est unitaire.
   Solveur_split simplifie systématiquement par le premier littéral de la première clause, 
   tandis que solveur_dpll_rec privilégie la simplification par les unitaires, puis par les les littéraux purs
   on s'assure ainsi de ne pas construire des branches qui ne mènent pas au résultat. 
   solveur_dpll_rec doit trouver les littéraux unitaires et purs car leurs simplifications ne crée pas d'embranchement, 
   tandis que solveur_split teste toutes les possibilités, créant de nombreux embranchement, ce qui peut être long si il y a beaucoup de clauses. 


---

5. Avez-vous d'autres remarques sur votre rendu ? (question optionnelle)

-> - Pour implémenter `pur` de manière plus efficace, on pourrait trouver un moyen de traverser la
   liste savoir si c'est un littéral pur et retirer les occurences de ce littéral et son opposé dans 
   la même boucle, pour éviter de traverser deux fois la liste.
   - impossible de résoudre sudoku-9x9-god.cnf avec notre algorithme. 


---

--fin du fichier RENDU--